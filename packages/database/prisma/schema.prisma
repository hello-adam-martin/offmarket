generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

// ============================================================================
// USER & AUTH
// ============================================================================

model User {
  id            String    @id @default(cuid())
  email         String    @unique
  emailVerified DateTime?
  name          String?
  phone         String?
  image         String?
  role          UserRole  @default(USER)
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  // Stripe
  stripeCustomerId String? @unique

  // Auth relations
  accounts Account[]
  sessions Session[]

  // Platform relations
  buyerProfile  BuyerProfile?
  ownerProfile  OwnerProfile?
  notifications Notification[]
  savedSearches SavedSearch[]
  subscription  Subscription?
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

// ============================================================================
// BUYER PROFILES & WANTED ADS
// ============================================================================

model BuyerProfile {
  id        String   @id @default(cuid())
  userId    String   @unique
  bio       String?
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user             User              @relation(fields: [userId], references: [id], onDelete: Cascade)
  wantedAds        WantedAd[]
  inquiries        Inquiry[]
  escrowDeposits   EscrowDeposit[]
  postcardRequests PostcardRequest[]
}

// A "wanted" ad - buyer expressing interest in a property/area
model WantedAd {
  id          String   @id @default(cuid())
  buyerId     String
  title       String
  description String?

  // Budget (single price point the buyer is interested at)
  budget        Int
  financeStatus FinanceStatus?

  // Property requirements (stored as JSON strings for SQLite compatibility)
  propertyTypes String?   // JSON array of PropertyType values
  bedroomsMin   Int?
  bedroomsMax   Int?
  bathroomsMin  Int?
  landSizeMin   Int? // in sqm
  landSizeMax   Int?
  floorAreaMin  Int? // in sqm
  floorAreaMax  Int?

  // Features wanted (stored as JSON string for SQLite compatibility)
  features      String?   // JSON array of PropertyFeature values

  // Location targeting
  targetType    TargetType  @default(AREA)

  // Status
  isActive      Boolean     @default(true)
  expiresAt     DateTime?
  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt

  buyer             BuyerProfile        @relation(fields: [buyerId], references: [id], onDelete: Cascade)
  targetLocations   TargetLocation[]
  targetAddresses   TargetAddress[]
  matchingProperties PropertyMatch[]
  postcardRequests  PostcardRequest[]

  @@index([isActive, targetType])  // Composite index for common filter queries
}

// Specific address a buyer is interested in
model TargetAddress {
  id          String   @id @default(cuid())
  wantedAdId  String
  address     String
  suburb      String?
  city        String?
  region      String?
  postcode    String?

  // Geocoded coordinates (for map display and matching)
  latitude    Float?
  longitude   Float?

  // Property data (fetched from external sources or manually entered)
  // Contains: propertyType, yearBuilt, landArea, floorArea, bedrooms, bathrooms, garages,
  // capitalValue, landValue, improvementsValue, valuationDate, features, streetViewUrl, aerialViewUrl
  propertyData String? // JSON

  createdAt   DateTime @default(now())

  wantedAd         WantedAd          @relation(fields: [wantedAdId], references: [id], onDelete: Cascade)
  postcardRequests PostcardRequest[]

  @@index([suburb, city])
  @@index([wantedAdId])           // JOIN optimization
  @@index([region])               // Filter by region
}

// Area/region a buyer is interested in (suburb, city, region)
model TargetLocation {
  id          String        @id @default(cuid())
  wantedAdId  String
  locationType LocationType
  name        String        // e.g., "Ponsonby", "Auckland", "Northland"

  // Boundary data for area matching
  boundaryGeoJson String?

  createdAt   DateTime      @default(now())

  wantedAd    WantedAd      @relation(fields: [wantedAdId], references: [id], onDelete: Cascade)

  @@index([locationType, name])
  @@index([wantedAdId])            // JOIN optimization
}

// ============================================================================
// OWNER PROFILES & PROPERTIES
// ============================================================================

model OwnerProfile {
  id        String   @id @default(cuid())
  userId    String   @unique
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user           User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  properties     Property[]
  escrowDeposits EscrowDeposit[]
}

// An owner's property (not publicly listed, but can check demand)
model Property {
  id          String   @id @default(cuid())
  ownerId     String

  // Address
  address     String
  suburb      String?
  city        String?
  region      String?
  postcode    String?

  // Geocoded coordinates
  latitude    Float?
  longitude   Float?

  // Property details
  propertyType  String?   // One of: HOUSE, APARTMENT, TOWNHOUSE, UNIT, LIFESTYLE, SECTION, FARM, COMMERCIAL
  bedrooms      Int?
  bathrooms     Int?
  landSize      Int?     // sqm
  floorArea     Int?     // sqm
  yearBuilt     Int?

  // Features (stored as JSON string for SQLite compatibility)
  features      String?   // JSON array of PropertyFeature values

  // Valuation (owner's estimate or RV)
  estimatedValue Int?
  rvValue        Int?    // Rateable Value

  // Verification status
  isVerified    Boolean  @default(false)
  verifiedAt    DateTime?

  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  owner          OwnerProfile    @relation(fields: [ownerId], references: [id], onDelete: Cascade)
  matches        PropertyMatch[]
  inquiries      Inquiry[]
  images         PropertyImage[]
  escrowDeposits EscrowDeposit[]

  @@unique([address, suburb, city])
  @@index([suburb, city, region])
}

// Property images uploaded by owner
model PropertyImage {
  id          String   @id @default(cuid())
  propertyId  String
  url         String   // Vercel Blob URL or local path
  filename    String
  size        Int      // File size in bytes
  order       Int      @default(0)  // Display order
  isPrimary   Boolean  @default(false)
  createdAt   DateTime @default(now())

  property    Property @relation(fields: [propertyId], references: [id], onDelete: Cascade)

  @@index([propertyId])
}

// ============================================================================
// MATCHING & INQUIRIES
// ============================================================================

// Matches between wanted ads and properties
model PropertyMatch {
  id          String   @id @default(cuid())
  wantedAdId  String
  propertyId  String

  // Match quality score (0-100)
  matchScore  Int

  // Match type: DIRECT = buyer named this specific address, CRITERIA = matches general search criteria
  matchType   MatchType @default(CRITERIA)

  // What aspects matched (stored as JSON string for SQLite compatibility)
  matchedOn   String   // JSON array, e.g., '["location", "budget", "bedrooms"]'

  // Status tracking
  viewedByOwner   Boolean   @default(false)
  viewedAt        DateTime?

  createdAt   DateTime @default(now())

  wantedAd    WantedAd @relation(fields: [wantedAdId], references: [id], onDelete: Cascade)
  property    Property @relation(fields: [propertyId], references: [id], onDelete: Cascade)

  @@unique([wantedAdId, propertyId])
  @@index([propertyId])
}

enum MatchType {
  DIRECT    // Buyer specifically named this property address
  CRITERIA  // Property matches buyer's general search criteria
}

// Owner reaching out to a buyer (or vice versa)
model Inquiry {
  id          String        @id @default(cuid())
  propertyId  String
  buyerId     String

  initiatedBy InquiryInitiator
  message     String
  status      InquiryStatus @default(PENDING)

  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt

  property      Property        @relation(fields: [propertyId], references: [id], onDelete: Cascade)
  buyer         BuyerProfile    @relation(fields: [buyerId], references: [id], onDelete: Cascade)
  messages      InquiryMessage[]
  escrowDeposit EscrowDeposit?
}

model InquiryMessage {
  id         String   @id @default(cuid())
  inquiryId  String
  senderId   String   // User ID
  message    String
  isRead     Boolean  @default(false)
  createdAt  DateTime @default(now())

  inquiry    Inquiry  @relation(fields: [inquiryId], references: [id], onDelete: Cascade)
}

// ============================================================================
// NOTIFICATIONS
// ============================================================================

model Notification {
  id        String           @id @default(cuid())
  userId    String
  type      NotificationType
  title     String
  message   String
  data      Json?            // Additional context
  isRead    Boolean          @default(false)
  createdAt DateTime         @default(now())

  user      User             @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, isRead])
}

// ============================================================================
// SAVED SEARCHES
// ============================================================================

// User's saved search criteria for finding properties or demand
model SavedSearch {
  id        String           @id @default(cuid())
  userId    String
  name      String           // User-friendly name for the search
  type      SavedSearchType  // DEMAND or PROPERTY

  // Search criteria (stored as JSON for flexibility)
  region    String?
  city      String?
  suburb    String?
  propertyTypes String?      // JSON array
  bedroomsMin   Int?
  bedroomsMax   Int?
  budgetMin     Int?
  budgetMax     Int?

  // Notification preferences
  notifyOnNew   Boolean      @default(true)  // Notify when new matches appear
  lastNotified  DateTime?

  createdAt DateTime         @default(now())
  updatedAt DateTime         @updatedAt

  user      User             @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

// ============================================================================
// ENUMS
// ============================================================================

// Note: PropertyType and PropertyFeature are stored as JSON strings for SQLite
// Valid PropertyType values: HOUSE, APARTMENT, TOWNHOUSE, UNIT, LIFESTYLE, SECTION, FARM, COMMERCIAL
// Valid PropertyFeature values: GARAGE, POOL, DECK, GARDEN, SEA_VIEW, MOUNTAIN_VIEW, OFF_STREET_PARKING, ENSUITE, HEAT_PUMP, FIREPLACE, NEW_BUILD, RENOVATED, FENCED, PET_FRIENDLY

enum TargetType {
  SPECIFIC_ADDRESS
  AREA
  BOTH
}

enum FinanceStatus {
  CASH
  PRE_APPROVED
  REQUIRES_FINANCE
  NOT_SPECIFIED
}

enum LocationType {
  SUBURB
  CITY
  DISTRICT
  REGION
}

enum InquiryInitiator {
  OWNER
  BUYER
}

enum InquiryStatus {
  PENDING
  ACCEPTED
  DECLINED
  COMPLETED
}

enum NotificationType {
  NEW_MATCH
  NEW_INQUIRY
  INQUIRY_RESPONSE
  PROPERTY_INTEREST
  SYSTEM
}

enum SavedSearchType {
  DEMAND    // Searching for buyer demand (for property owners)
  PROPERTY  // Searching for properties (for buyers)
}

enum UserRole {
  USER
  ADMIN
}

// ============================================================================
// ADMIN & SYSTEM
// ============================================================================

model EmailTemplate {
  id          String   @id @default(cuid())
  name        String   @unique  // e.g., "new_inquiry", "new_match"
  subject     String
  htmlContent String   // HTML with {{variables}}
  textContent String?  // Plain text fallback
  isActive    Boolean  @default(true)
  updatedAt   DateTime @updatedAt
  createdAt   DateTime @default(now())
}

model SystemSetting {
  id        String   @id @default(cuid())
  key       String   @unique
  value     String
  updatedAt DateTime @updatedAt
}

// ============================================================================
// BILLING & SUBSCRIPTIONS
// ============================================================================

model Subscription {
  id                   String             @id @default(cuid())
  userId               String             @unique
  stripeSubscriptionId String?            @unique
  tier                 SubscriptionTier   @default(FREE)
  status               SubscriptionStatus @default(ACTIVE)
  currentPeriodStart   DateTime?
  currentPeriodEnd     DateTime?
  canceledAt           DateTime?
  createdAt            DateTime           @default(now())
  updatedAt            DateTime           @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

enum SubscriptionTier {
  FREE
  PRO
}

enum SubscriptionStatus {
  ACTIVE
  PAST_DUE
  CANCELED
  INCOMPLETE
}

// Escrow deposit for owner finder's fee when contacting buyers
model EscrowDeposit {
  id              String       @id @default(cuid())
  ownerId         String
  propertyId      String
  buyerId         String
  amount          Int          // Amount in cents
  stripePaymentId String?      @unique
  status          EscrowStatus @default(PENDING)
  inquiryId       String?      @unique
  refundedAt      DateTime?
  releasedAt      DateTime?
  expiresAt       DateTime     // Auto-refund if no connection in 30 days
  createdAt       DateTime     @default(now())

  owner    OwnerProfile @relation(fields: [ownerId], references: [id])
  property Property     @relation(fields: [propertyId], references: [id])
  buyer    BuyerProfile @relation(fields: [buyerId], references: [id])
  inquiry  Inquiry?     @relation(fields: [inquiryId], references: [id])

  @@index([ownerId])
  @@index([status])
}

enum EscrowStatus {
  PENDING  // Payment initiated
  HELD     // Payment successful, funds held
  RELEASED // Deal completed, funds released to platform
  REFUNDED // No deal, funds returned to owner
  EXPIRED  // Auto-refunded after 30 days
}

// ============================================================================
// POSTCARD DIRECT MAIL
// ============================================================================

// Postcard request from a buyer to send physical mail to property owner
model PostcardRequest {
  id              String         @id @default(cuid())
  buyerId         String
  wantedAdId      String
  targetAddressId String

  // Recipient address (copied from TargetAddress for record-keeping)
  recipientAddress  String
  recipientSuburb   String?
  recipientCity     String?
  recipientRegion   String?
  recipientPostcode String?

  // Unique claim code for owner to respond
  claimCode       String         @unique @default(cuid())

  // Buyer-configured content options
  showBudget        Boolean      @default(false)
  showFinanceStatus Boolean      @default(false)
  showTimeline      Boolean      @default(false)
  customMessage     String?      // Optional personal note (max 200 chars)

  // Status tracking
  status          PostcardStatus @default(PENDING)

  // Payment (0 if using free allowance)
  costInCents     Int            @default(0)
  stripePaymentId String?        @unique

  // Admin/fulfillment
  reviewedAt      DateTime?
  reviewedBy      String?        // Admin userId who approved/rejected
  rejectionReason String?

  // Fulfillment tracking
  providerOrderId String?        // External API order ID (for future)
  trackingNumber  String?

  sentAt          DateTime?
  deliveredAt     DateTime?
  failedAt        DateTime?
  failureReason   String?

  // Owner response (when they claim/respond via the claim code)
  claimedAt         DateTime?      // When owner first viewed
  ownerResponseAt   DateTime?      // When owner submitted response
  ownerName         String?
  ownerEmail        String?
  ownerPhone        String?
  ownerMessage      String?

  createdAt       DateTime       @default(now())
  updatedAt       DateTime       @updatedAt

  buyer       BuyerProfile  @relation(fields: [buyerId], references: [id])
  wantedAd    WantedAd      @relation(fields: [wantedAdId], references: [id])
  targetAddr  TargetAddress @relation(fields: [targetAddressId], references: [id])

  @@index([buyerId])
  @@index([status])
  @@index([createdAt])
}

enum PostcardStatus {
  PENDING   // Awaiting admin review
  APPROVED  // Ready to send
  REJECTED  // Admin rejected
  SENT      // Mailed out
  DELIVERED // Confirmed delivery (if tracking available)
  FAILED    // Failed to deliver
}
